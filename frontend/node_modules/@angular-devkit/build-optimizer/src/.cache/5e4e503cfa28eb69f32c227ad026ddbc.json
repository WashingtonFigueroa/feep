{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\operators\\tap.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\operators\\tap.js","mtime":1548987628387},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Subscriber } from '../Subscriber';\r\nimport { noop } from '../util/noop';\r\nimport { isFunction } from '../util/isFunction';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Perform a side effect for every emission on the source Observable, but return\r\n * an Observable that is identical to the source.\r\n *\r\n * <span class=\"informal\">Intercepts each emission on the source and runs a\r\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\r\n *\r\n * <img src=\"./img/do.png\" width=\"100%\">\r\n *\r\n * Returns a mirrored Observable of the source Observable, but modified so that\r\n * the provided Observer is called to perform a side effect for every value,\r\n * error, and completion emitted by the source. Any errors that are thrown in\r\n * the aforementioned Observer or handlers are safely sent down the error path\r\n * of the output Observable.\r\n *\r\n * This operator is useful for debugging your Observables for the correct values\r\n * or performing other side effects.\r\n *\r\n * Note: this is different to a `subscribe` on the Observable. If the Observable\r\n * returned by `do` is not subscribed, the side effects specified by the\r\n * Observer will never happen. `do` therefore simply spies on existing\r\n * execution, it does not trigger an execution to happen like `subscribe` does.\r\n *\r\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var positions = clicks\r\n *   .do(ev => console.log(ev))\r\n *   .map(ev => ev.clientX);\r\n * positions.subscribe(x => console.log(x));\r\n *\r\n * @see {@link map}\r\n * @see {@link subscribe}\r\n *\r\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\r\n * callback for `next`.\r\n * @param {function} [error] Callback for errors in the source.\r\n * @param {function} [complete] Callback for the completion of the source.\r\n * @return {Observable} An Observable identical to the source, but runs the\r\n * specified Observer or callback(s) for each item.\r\n * @name tap\r\n */\r\nexport function tap(nextOrObserver, error, complete) {\r\n    return function tapOperatorFunction(source) {\r\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\r\n    };\r\n}\r\nvar DoOperator = /*@__PURE__*/ (function () {\r\n    function DoOperator(nextOrObserver, error, complete) {\r\n        this.nextOrObserver = nextOrObserver;\r\n        this.error = error;\r\n        this.complete = complete;\r\n    }\r\n    DoOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\r\n    };\r\n    return DoOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar TapSubscriber = (function (_super) {\r\n    tslib_1.__extends(TapSubscriber, _super);\r\n    function TapSubscriber(destination, observerOrNext, error, complete) {\r\n        var _this = _super.call(this, destination) || this;\r\n        _this._tapNext = noop;\r\n        _this._tapError = noop;\r\n        _this._tapComplete = noop;\r\n        _this._tapError = error || noop;\r\n        _this._tapComplete = complete || noop;\r\n        if (isFunction(observerOrNext)) {\r\n            _this._context = _this;\r\n            _this._tapNext = observerOrNext;\r\n        }\r\n        else if (observerOrNext) {\r\n            _this._context = observerOrNext;\r\n            _this._tapNext = observerOrNext.next || noop;\r\n            _this._tapError = observerOrNext.error || noop;\r\n            _this._tapComplete = observerOrNext.complete || noop;\r\n        }\r\n        return _this;\r\n    }\r\n    TapSubscriber.prototype._next = function (value) {\r\n        try {\r\n            this._tapNext.call(this._context, value);\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n            return;\r\n        }\r\n        this.destination.next(value);\r\n    };\r\n    TapSubscriber.prototype._error = function (err) {\r\n        try {\r\n            this._tapError.call(this._context, err);\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n            return;\r\n        }\r\n        this.destination.error(err);\r\n    };\r\n    TapSubscriber.prototype._complete = function () {\r\n        try {\r\n            this._tapComplete.call(this._context);\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n            return;\r\n        }\r\n        return this.destination.complete();\r\n    };\r\n    return TapSubscriber;\r\n}(Subscriber));\r\n//# sourceMappingURL=tap.js.map\r\n",null]}