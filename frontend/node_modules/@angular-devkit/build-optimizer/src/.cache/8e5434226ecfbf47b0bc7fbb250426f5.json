{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\empty.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\empty.js","mtime":1548987628266},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\n/**\r\n * The same Observable instance returned by any call to {@link empty} without a\r\n * {@link Scheduler}. It is preferrable to use this over `empty()`.\r\n */\r\nexport var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });\r\n/**\r\n * Creates an Observable that emits no items to the Observer and immediately\r\n * emits a complete notification.\r\n *\r\n * <span class=\"informal\">Just emits 'complete', and nothing else.\r\n * </span>\r\n *\r\n * <img src=\"./img/empty.png\" width=\"100%\">\r\n *\r\n * This static operator is useful for creating a simple Observable that only\r\n * emits the complete notification. It can be used for composing with other\r\n * Observables, such as in a {@link mergeMap}.\r\n *\r\n * @example <caption>Emit the number 7, then complete.</caption>\r\n * var result = Rx.Observable.empty().startWith(7);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\r\n * var interval = Rx.Observable.interval(1000);\r\n * var result = interval.mergeMap(x =>\r\n *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following to the console:\r\n * // x is equal to the count on the interval eg(0,1,2,3,...)\r\n * // x will occur every 1000ms\r\n * // if x % 2 is equal to 1 print abc\r\n * // if x % 2 is not equal to 1 nothing will be output\r\n *\r\n * @see {@link create}\r\n * @see {@link never}\r\n * @see {@link of}\r\n * @see {@link throw}\r\n *\r\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\r\n * the emission of the complete notification.\r\n * @return {Observable} An \"empty\" Observable: emits only the complete\r\n * notification.\r\n * @static true\r\n * @name empty\r\n * @owner Observable\r\n * @deprecated Deprecated in favor of using EMPTY constant.\r\n */\r\nexport function empty(scheduler) {\r\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\r\n}\r\nexport function emptyScheduled(scheduler) {\r\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\r\n}\r\n//# sourceMappingURL=empty.js.map\r\n",null]}