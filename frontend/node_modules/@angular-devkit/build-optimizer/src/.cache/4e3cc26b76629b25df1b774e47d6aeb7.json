{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\onErrorResumeNext.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\onErrorResumeNext.js","mtime":1548987628279},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { from } from './from';\r\nimport { isArray } from '../util/isArray';\r\nimport { EMPTY } from './empty';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\r\n * that was passed.\r\n *\r\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\r\n *\r\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\r\n *\r\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\r\n * If the source it's subscribed to emits an error or completes, it will move to the next source\r\n * without error.\r\n *\r\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\r\n *\r\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\r\n * sources emits an error.\r\n *\r\n * Note that there is no way to handle any errors thrown by sources via the resuult of\r\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\r\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\r\n *\r\n * @example <caption>Subscribe to the next Observable after map fails</caption>\r\n * import { onErrorResumeNext, of } from 'rxjs/create';\r\n * import { map } from 'rxjs/operators';\r\n *\r\n * onErrorResumeNext(\r\n *  of(1, 2, 3, 0).pipe(\r\n *    map(x => {\r\n *      if (x === 0) throw Error();\r\n *      return 10 / x;\r\n *    })\r\n *  ),\r\n *  of(1, 2, 3),\r\n * )\r\n * .subscribe(\r\n *   val => console.log(val),\r\n *   err => console.log(err),          // Will never be called.\r\n *   () => console.log('done')\r\n * );\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 5\r\n * // 3.3333333333333335\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // \"done\"\r\n *\r\n * @see {@link concat}\r\n * @see {@link catch}\r\n *\r\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\r\n * @return {Observable} An Observable that concatenates all sources, one after the other,\r\n * ignoring all errors, such that any error causes it to move on to the next source.\r\n */\r\nexport function onErrorResumeNext() {\r\n    var sources = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        sources[_i] = arguments[_i];\r\n    }\r\n    if (sources.length === 0) {\r\n        return EMPTY;\r\n    }\r\n    var first = sources[0], remainder = sources.slice(1);\r\n    if (sources.length === 1 && isArray(first)) {\r\n        return onErrorResumeNext.apply(void 0, first);\r\n    }\r\n    return new Observable(function (subscriber) {\r\n        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };\r\n        return from(first).subscribe({\r\n            next: function (value) { subscriber.next(value); },\r\n            error: subNext,\r\n            complete: subNext,\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=onErrorResumeNext.js.map\r\n",null]}