{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\interval.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\interval.js","mtime":1548987628276},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { async } from '../scheduler/async';\r\nimport { isNumeric } from '../util/isNumeric';\r\n/**\r\n * Creates an Observable that emits sequential numbers every specified\r\n * interval of time, on a specified IScheduler.\r\n *\r\n * <span class=\"informal\">Emits incremental numbers periodically in time.\r\n * </span>\r\n *\r\n * <img src=\"./img/interval.png\" width=\"100%\">\r\n *\r\n * `interval` returns an Observable that emits an infinite sequence of\r\n * ascending integers, with a constant interval of time of your choosing\r\n * between those emissions. The first emission is not sent immediately, but\r\n * only after the first period has passed. By default, this operator uses the\r\n * `async` IScheduler to provide a notion of time, but you may pass any\r\n * IScheduler to it.\r\n *\r\n * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\r\n * var numbers = Rx.Observable.interval(1000);\r\n * numbers.subscribe(x => console.log(x));\r\n *\r\n * @see {@link timer}\r\n * @see {@link delay}\r\n *\r\n * @param {number} [period=0] The interval size in milliseconds (by default)\r\n * or the time unit determined by the scheduler's clock.\r\n * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\r\n * the emission of values, and providing a notion of \"time\".\r\n * @return {Observable} An Observable that emits a sequential number each time\r\n * interval.\r\n * @static true\r\n * @name interval\r\n * @owner Observable\r\n */\r\nexport function interval(period, scheduler) {\r\n    if (period === void 0) {\r\n        period = 0;\r\n    }\r\n    if (scheduler === void 0) {\r\n        scheduler = async;\r\n    }\r\n    if (!isNumeric(period) || period < 0) {\r\n        period = 0;\r\n    }\r\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\r\n        scheduler = async;\r\n    }\r\n    return new Observable(function (subscriber) {\r\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\r\n        return subscriber;\r\n    });\r\n}\r\nfunction dispatch(state) {\r\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\r\n    subscriber.next(counter);\r\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\r\n}\r\n//# sourceMappingURL=interval.js.map\r\n",null]}