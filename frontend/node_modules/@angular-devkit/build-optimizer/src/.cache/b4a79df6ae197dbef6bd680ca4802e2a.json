{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\using.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\using.js","mtime":1548987628284},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { from } from './from'; // from from from! LAWL\r\nimport { EMPTY } from './empty';\r\n/**\r\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\r\n *\r\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\r\n *\r\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\r\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\r\n * that object and should return an Observable. That Observable can use resource object during its execution.\r\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\r\n * resource object will be shared in any way between subscriptions.\r\n *\r\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\r\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\r\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\r\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\r\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\r\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\r\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\r\n * that implements `unsubscribe` method.\r\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\r\n * creates an Observable, that can use injected resource object.\r\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\r\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\r\n */\r\nexport function using(resourceFactory, observableFactory) {\r\n    return new Observable(function (subscriber) {\r\n        var resource;\r\n        try {\r\n            resource = resourceFactory();\r\n        }\r\n        catch (err) {\r\n            subscriber.error(err);\r\n            return undefined;\r\n        }\r\n        var result;\r\n        try {\r\n            result = observableFactory(resource);\r\n        }\r\n        catch (err) {\r\n            subscriber.error(err);\r\n            return undefined;\r\n        }\r\n        var source = result ? from(result) : EMPTY;\r\n        var subscription = source.subscribe(subscriber);\r\n        return function () {\r\n            subscription.unsubscribe();\r\n            if (resource) {\r\n                resource.unsubscribe();\r\n            }\r\n        };\r\n    });\r\n}\r\n//# sourceMappingURL=using.js.map\r\n",null]}