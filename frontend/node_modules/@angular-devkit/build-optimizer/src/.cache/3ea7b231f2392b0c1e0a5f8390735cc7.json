{"remainingRequest":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\forkJoin.js","dependencies":[{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\forkJoin.js","mtime":1549240439757},{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1549240389071},{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1549240333687}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { isArray } from '../util/isArray';\r\nimport { EMPTY } from './empty';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { map } from '../operators/map';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Joins last values emitted by passed Observables.\r\n *\r\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\r\n *\r\n * <img src=\"./img/forkJoin.png\" width=\"100%\">\r\n *\r\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\r\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\r\n * immediately.\r\n *\r\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\r\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\r\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\r\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\r\n * not emit more than once and it will complete after that. If you need to emit combined values not only\r\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\r\n * or {@link zip} instead.\r\n *\r\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\r\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n * and it will not emit anything either, even if it already has some last values from other Observables.\r\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\r\n * unless at any point some other Observable completes without emitting value, which brings us back to\r\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\r\n * have to emit something at least once and complete.\r\n *\r\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\r\n * will be immediately unsubscribed.\r\n *\r\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\r\n * would land in emitted array. Whatever is returned by project function, will appear in output\r\n * Observable instead. This means that default project can be thought of as a function that takes\r\n * all its arguments and puts them into an array. Note that project function will be called only\r\n * when output Observable is supposed to emit a result.\r\n *\r\n * @example <caption>Use forkJoin with operator emitting immediately</caption>\r\n * import { forkJoin, of } from 'rxjs';\r\n *\r\n * const observable = forkJoin(\r\n *   of(1, 2, 3, 4),\r\n *   of(5, 6, 7, 8)\r\n * );\r\n * observable.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('This is how it ends!')\r\n * );\r\n *\r\n * // Logs:\r\n * // [4, 8]\r\n * // \"This is how it ends!\"\r\n *\r\n *\r\n * @example <caption>Use forkJoin with operator emitting after some time</caption>\r\n * import { forkJoin, interval } from 'rxjs';\r\n * import { take } from 'rxjs/operators';\r\n *\r\n * const observable = forkJoin(\r\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\r\n *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete\r\n * );\r\n * observable.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('This is how it ends!')\r\n * );\r\n *\r\n * // Logs:\r\n * // [2, 3] after 3 seconds\r\n * // \"This is how it ends!\" immediately after\r\n *\r\n *\r\n * @example <caption>Use forkJoin with project function</caption>\r\n * import { jorkJoin, interval } from 'rxjs';\r\n * import { take } from 'rxjs/operators';\r\n *\r\n * const observable = forkJoin(\r\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\r\n *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete\r\n *   (n, m) => n + m\r\n * );\r\n * observable.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('This is how it ends!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 5 after 3 seconds\r\n * // \"This is how it ends!\" immediately after\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link zip}\r\n *\r\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\r\n * passed directly to the operator.\r\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\r\n * that will appear in resulting Observable instead of default array.\r\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\r\n * or value from project function.\r\n */\r\nexport function forkJoin() {\r\n    var sources = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        sources[_i] = arguments[_i];\r\n    }\r\n    var resultSelector;\r\n    if (typeof sources[sources.length - 1] === 'function') {\r\n        // DEPRECATED PATH\r\n        resultSelector = sources.pop();\r\n    }\r\n    // if the first and only other argument is an array\r\n    // assume it's been called with `forkJoin([obs1, obs2, obs3])`\r\n    if (sources.length === 1 && isArray(sources[0])) {\r\n        sources = sources[0];\r\n    }\r\n    if (sources.length === 0) {\r\n        return EMPTY;\r\n    }\r\n    if (resultSelector) {\r\n        // DEPRECATED PATH\r\n        return forkJoin(sources).pipe(map(function (args) { return resultSelector.apply(void 0, args); }));\r\n    }\r\n    return new Observable(function (subscriber) {\r\n        return new ForkJoinSubscriber(subscriber, sources);\r\n    });\r\n}\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(ForkJoinSubscriber, _super);\r\n    function ForkJoinSubscriber(destination, sources) {\r\n        var _this = _super.call(this, destination) || this;\r\n        _this.sources = sources;\r\n        _this.completed = 0;\r\n        _this.haveValues = 0;\r\n        var len = sources.length;\r\n        _this.values = new Array(len);\r\n        for (var i = 0; i < len; i++) {\r\n            var source = sources[i];\r\n            var innerSubscription = subscribeToResult(_this, source, null, i);\r\n            if (innerSubscription) {\r\n                _this.add(innerSubscription);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.values[outerIndex] = innerValue;\r\n        if (!innerSub._hasValue) {\r\n            innerSub._hasValue = true;\r\n            this.haveValues++;\r\n        }\r\n    };\r\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\r\n        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;\r\n        var len = values.length;\r\n        if (!innerSub._hasValue) {\r\n            destination.complete();\r\n            return;\r\n        }\r\n        this.completed++;\r\n        if (this.completed !== len) {\r\n            return;\r\n        }\r\n        if (haveValues === len) {\r\n            destination.next(values);\r\n        }\r\n        destination.complete();\r\n    };\r\n    return ForkJoinSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=forkJoin.js.map\r\n",null]}