{"remainingRequest":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\timer.js","dependencies":[{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\timer.js","mtime":1549240439835},{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1549240389071},{"path":"C:\\Users\\HP User\\Documents\\trabajos\\washington\\fepp\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1549240333687}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { async } from '../scheduler/async';\r\nimport { isNumeric } from '../util/isNumeric';\r\nimport { isScheduler } from '../util/isScheduler';\r\n/**\r\n * Creates an Observable that starts emitting after an `initialDelay` and\r\n * emits ever increasing numbers after each `period` of time thereafter.\r\n *\r\n * <span class=\"informal\">Its like {@link interval}, but you can specify when\r\n * should the emissions start.</span>\r\n *\r\n * <img src=\"./img/timer.png\" width=\"100%\">\r\n *\r\n * `timer` returns an Observable that emits an infinite sequence of ascending\r\n * integers, with a constant interval of time, `period` of your choosing\r\n * between those emissions. The first emission happens after the specified\r\n * `initialDelay`. The initial delay may be a {@link Date}. By default, this\r\n * operator uses the `async` IScheduler to provide a notion of time, but you\r\n * may pass any IScheduler to it. If `period` is not specified, the output\r\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\r\n * sequence.\r\n *\r\n * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\r\n * var numbers = Rx.Observable.timer(3000, 1000);\r\n * numbers.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Emits one number after five seconds</caption>\r\n * var numbers = Rx.Observable.timer(5000);\r\n * numbers.subscribe(x => console.log(x));\r\n *\r\n * @see {@link interval}\r\n * @see {@link delay}\r\n *\r\n * @param {number|Date} [dueTime] The initial delay time to wait before\r\n * emitting the first value of `0`.\r\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\r\n * subsequent numbers.\r\n * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling\r\n * the emission of values, and providing a notion of \"time\".\r\n * @return {Observable} An Observable that emits a `0` after the\r\n * `initialDelay` and ever increasing numbers after each `period` of time\r\n * thereafter.\r\n * @static true\r\n * @name timer\r\n * @owner Observable\r\n */\r\nexport function timer(dueTime, periodOrScheduler, scheduler) {\r\n    if (dueTime === void 0) {\r\n        dueTime = 0;\r\n    }\r\n    var period = -1;\r\n    if (isNumeric(periodOrScheduler)) {\r\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\r\n    }\r\n    else if (isScheduler(periodOrScheduler)) {\r\n        scheduler = periodOrScheduler;\r\n    }\r\n    if (!isScheduler(scheduler)) {\r\n        scheduler = async;\r\n    }\r\n    return new Observable(function (subscriber) {\r\n        var due = isNumeric(dueTime)\r\n            ? dueTime\r\n            : (+dueTime - scheduler.now());\r\n        return scheduler.schedule(dispatch, due, {\r\n            index: 0, period: period, subscriber: subscriber\r\n        });\r\n    });\r\n}\r\nfunction dispatch(state) {\r\n    var index = state.index, period = state.period, subscriber = state.subscriber;\r\n    subscriber.next(index);\r\n    if (subscriber.closed) {\r\n        return;\r\n    }\r\n    else if (period === -1) {\r\n        return subscriber.complete();\r\n    }\r\n    state.index = index + 1;\r\n    this.schedule(state, period);\r\n}\r\n//# sourceMappingURL=timer.js.map\r\n",null]}