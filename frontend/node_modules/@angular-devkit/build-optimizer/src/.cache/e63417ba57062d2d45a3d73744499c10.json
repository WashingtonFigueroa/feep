{"remainingRequest":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\bindNodeCallback.js","dependencies":[{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\rxjs\\_esm5\\internal\\observable\\bindNodeCallback.js","mtime":1548987628259},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1548987609424},{"path":"C:\\wamp64\\www\\DTMOWED\\feep\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1548987590941}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\r\nimport { Observable } from '../Observable';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\nimport { map } from '../operators/map';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isArray } from '../util/isArray';\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper {@link Scheduler} provided as optional third parameter. Scheduler\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * Scheduler works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n *\r\n * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\r\n * import * as fs from 'fs';\r\n * var readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * var result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n *\r\n *\r\n * @example <caption>Use on function calling callback with multiple arguments</caption>\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * var boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n *\r\n * @example <caption>Use on function calling callback in regular style</caption>\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * var boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n *\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n * @see {@link fromPromise}\r\n *\r\n * @param {function} func Function with a Node.js-style callback as the last parameter.\r\n * @param {Scheduler} [scheduler] The scheduler on which to schedule the\r\n * callbacks.\r\n * @return {function(...params: *): Observable} A function which returns the\r\n * Observable that delivers the same values the Node.js callback would\r\n * deliver.\r\n * @name bindNodeCallback\r\n */\r\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\r\n    if (resultSelector) {\r\n        if (isScheduler(resultSelector)) {\r\n            scheduler = resultSelector;\r\n        }\r\n        else {\r\n            // DEPRECATED PATH\r\n            return function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\r\n            };\r\n        }\r\n    }\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var params = {\r\n            subject: undefined,\r\n            args: args,\r\n            callbackFunc: callbackFunc,\r\n            scheduler: scheduler,\r\n            context: this,\r\n        };\r\n        return new Observable(function (subscriber) {\r\n            var context = params.context;\r\n            var subject = params.subject;\r\n            if (!scheduler) {\r\n                if (!subject) {\r\n                    subject = params.subject = new AsyncSubject();\r\n                    var handler = function () {\r\n                        var innerArgs = [];\r\n                        for (var _i = 0; _i < arguments.length; _i++) {\r\n                            innerArgs[_i] = arguments[_i];\r\n                        }\r\n                        var err = innerArgs.shift();\r\n                        if (err) {\r\n                            subject.error(err);\r\n                            return;\r\n                        }\r\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\r\n                        subject.complete();\r\n                    };\r\n                    try {\r\n                        callbackFunc.apply(context, args.concat([handler]));\r\n                    }\r\n                    catch (err) {\r\n                        subject.error(err);\r\n                    }\r\n                }\r\n                return subject.subscribe(subscriber);\r\n            }\r\n            else {\r\n                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });\r\n            }\r\n        });\r\n    };\r\n}\r\nfunction dispatch(state) {\r\n    var _this = this;\r\n    var params = state.params, subscriber = state.subscriber, context = state.context;\r\n    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;\r\n    var subject = params.subject;\r\n    if (!subject) {\r\n        subject = params.subject = new AsyncSubject();\r\n        var handler = function () {\r\n            var innerArgs = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                innerArgs[_i] = arguments[_i];\r\n            }\r\n            var err = innerArgs.shift();\r\n            if (err) {\r\n                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\r\n            }\r\n            else {\r\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\r\n                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\r\n            }\r\n        };\r\n        try {\r\n            callbackFunc.apply(context, args.concat([handler]));\r\n        }\r\n        catch (err) {\r\n            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\r\n        }\r\n    }\r\n    this.add(subject.subscribe(subscriber));\r\n}\r\nfunction dispatchNext(arg) {\r\n    var value = arg.value, subject = arg.subject;\r\n    subject.next(value);\r\n    subject.complete();\r\n}\r\nfunction dispatchError(arg) {\r\n    var err = arg.err, subject = arg.subject;\r\n    subject.error(err);\r\n}\r\n//# sourceMappingURL=bindNodeCallback.js.map\r\n",null]}